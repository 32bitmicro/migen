from .structure import *
from .convtools import *
from functools import partial

def Convert(f, outs=set(), ins=set(), name="top", clkname="sys_clk", rstname="sys_rst"):
	ns = Namespace()
	
	clks = Signal(name=clkname)
	rsts = Signal(name=rstname)
	clk = ns.GetName(clks)
	rst = ns.GetName(rsts)
	
	def printsig(s):
		if s.bv.signed:
			n = "signed "
		else:
			n = ""
		if s.bv.width > 1:
			n += "[" + str(s.bv.width-1) + ":0] "
		n += ns.GetName(s)
		return n
	
	def printexpr(node):
		if isinstance(node, Constant):
			if node.n >= 0:
				return str(node.bv) + str(node.n)
			else:
				return "-" + str(node.bv) + str(-self.n)
		elif isinstance(node, Signal):
			return ns.GetName(node)
		elif isinstance(node, Operator):
			arity = len(node.operands)
			if arity == 1:
				r = self.op + printexpr(node.operands[0])
			elif arity == 2:
				r = printexpr(node.operands[0]) + " " + node.op + " " + printexpr(node.operands[1])
			else:
				raise TypeError
			return "(" + r + ")"
		elif isinstance(node, Slice):
			if node.start + 1 == node.stop:
				sr = "[" + str(node.start) + "]"
			else:
				sr = "[" + str(node.stop-1) + ":" + str(node.start) + "]"
			return printexpr(node.value) + sr
		elif isinstance(node, Cat):
			l = list(map(printexpr, node.l))
			l.reverse()
			return "{" + ", ".join(l) + "}"
		else:
			raise TypeError
	
	def printnode(level, node):
		if isinstance(node, Assign):
			# TODO: variables
			return "\t"*level + printexpr(node.l) + " <= " + printexpr(node.r) + ";\n"
		elif isinstance(node, StatementList):
			return "".join(list(map(partial(printnode, level), node.l)))
		elif isinstance(node, If):
			r = "\t"*level + "if (" + printexpr(node.cond) + ") begin\n"
			r += printnode(level + 1, node.t)
			if node.f.l:
				r += "\t"*level + "end else begin\n"
				r += printnode(level + 1, node.f)
			r += "\t"*level + "end\n"
			return r
		elif isinstance(node, Case):
			r = "\t"*level + "case (" + printexpr(node.test) + ")\n"
			for case in node.cases:
				r += "\t"*(level + 1) + printexpr(case[0]) + ": begin\n"
				r += printnode(level + 2, case[1])
				r += "\t"*(level + 1) + "end\n"
			r += "\t"*level + "endcase\n"
			return r
		else:
			raise TypeError
		
	r = "/* Autogenerated by Migen */\n"
	r += "module " + name + "(\n"
	r += "\tinput " + clk + ",\n"
	r += "\tinput " + rst
	if ins:
		r += ",\n\tinput " + ",\n\tinput ".join(map(printsig, ins)) 
	if outs:
		r += ",\n\toutput reg " + ",\n\toutput reg ".join(map(printsig, outs)) 
	r += "\n);\n\n"
	sigs = ListSignals(f).difference(ins, outs)
	for sig in sigs:
		r += "reg " + printsig(sig) + ";\n"
	r += "\n"
	
	if f.comb.l:
		r += "always @(*) begin\n"
		r += printnode(1, f.comb)
		r += "end\n\n"
	
	if f.sync.l:
		r += "always @(posedge " + clk + ") begin\n"
		r += printnode(1, InsertReset(rsts, f.sync))
		r += "end\n\n"
	
	r += "endmodule\n"
	
	return r